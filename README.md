# 프로젝트에서 배운 점

- 리액트를 사용한다면 프론트 서버에서 브라우저가 필요한 모든 것을 받아와야 하기 때문에 정작 백엔드 서버에서 API를 받아오는 시간까지 합한다면 다른 프레임워크들에 비해서 더 시간이 오래 걸릴 수도 있다. 하지만 로딩 페이지 등의 눈에 보이는 인터렉션을 통해서 조금이라도 늦어지는 로딩시간동안 사용자를 잡아놓을 수 있다는 장점이 있다. 실제로 이 로딩페이지는 역으로 검색 엔진에게 혼동을 주어 검색 순위가 밀릴 수 있다는 문제점이 있다.

## Next.js를 사용하는 이유

- Next.js를 사용하면 브라우저에서 전통적인 SSR 방식을 사용하며 처음으로 페이지를 방문할 때에 페이지에 존재하는 라우팅 링크를 통해 갈 수 있는 페이지의 뼈대까지도 모두 가져와 캐싱하므로 첫 로딩 시간은 걸리나 후에 캐싱된 데이터로 좀 더 빠른 로딩을 보여준다.

- Next.js에서는 ***import React from 'react'*** 구문을 ***생략하는 것이 가능***하다.
- 또한 pages 폴더내 파일들의 구조와 이름에 의거하여 라우팅 기능을 기본 제공한다.

> Next 9버전부터 추가 된 기능으로 동적 라우팅을 사용할 수도 있다.

## Inline Style을 사용하면 좋지 않은 이유

- 보통 Inline Style을 사용하게 되면 객체로 스타일을 전달하게 되는데 객체는 아무리 같은 값을 가지고 있더라도 가리키는 주소값이 다르므로 서로 다른 객체로 인식하게 된댜. 때문에 스타일로 적용한 값이 바뀌지 않았음에도 리렌더링이 되므로 사용하면 좋지 않다.
- 리액트에서는 styled-component를 사용해서 스타일을 대체하는 경우가 많다.
- styled-component를 사용하면 스타일로 인해 생기는 리렌더링을 막을 수 있다.

## 보안위협

- a 태그를 _blank 속성으로 열게 되면 언제나 opener를 참조할 수 있다. 때문에 부모 탭과 같은 스레드에서 페이지가 동작한다. Noopener 속성을 사용한다면 열린 탭은 부모를 호출 할 일이 없다.

  > Tabnabbing : a 태그의 target이 _blank인 경우 새롭게 열린 탭에서 기존 location을 피싱 사이트로 변경, 정보를 탈취하는 공격
- 몇 몇 취약한 웹사이트들은 메일을 통해서 옮겨짐

- 또한 Tabnabbing 등 악의적인 공격으로부터 무방비하므로 noopener noreferrer를 사용해서 새로운 페이지로 인해서 생길 수 있는 성능 저하를 막고 window.opener를 통한 악의적인 location 편경을 막을 수 있다.

- DEHYDRATE 새로 추가됨
- redux 연결 완료
- redux-devtools 연결
- react-devtools 사용
최적화를 위한 hooks 사용
- C# 공부 시작
- dependency 문제로 깃허브 풀리퀘
- 리액트 자체 소켓 문제로 보임
- 언어의 커다란 개념 이해를 위한 CODE 책 읽기 시작
- 큰 개념으로서의 컴퓨터 언어에 대한 이해가 필요
